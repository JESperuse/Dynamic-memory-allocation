## 一、动态分配内存的概述

在数组一章中，介绍过**数组的长度是事先定义好的，在整个程序中固定不变**，但是在实际的编程中，往往会发生这种情况，即**所需要的内存空间取决于实际输入的数据**，而无法预先确定。为了解决上述问题，C语言提供了一些**内存管理函数**，这些内存管理函数可以**按需要动态的分配内存函数，也可以把不在使用的空间回收再次利用**。

## 二、静态分配、动态分配

**静态分配**：

1、在程序编译或运行过程中，按事先规定大小分配内存空间的分配方式。int a [10]

2、必须事先知道所需空间大小。

3、分配在栈区或全局变量区，一般以数组的形式。

4、按计划分配。

动态分配：

1、在程序运行过程中，根据需要大小自由分配所需空间。

2、按需分配。

3、分配在堆区，一般使用特定的函数进行分配。

## 三、动态分配函数

**stdlib.h**

### **1、malloc函数**

**函数原型：void*malloc（unsigned int size);**

**功能说明：**在内存的动态存储区（堆区）中分配**一块长度为size字节的连续区域**，用来存放类型说明符指定的类型。函数原型返回void*指针，使用时必须做相应的强制类型转换，分配的内存空间内容不确定，一般使用memset初始化。

**返回值**：分配空间的起始地址（分配成功）

​                NULL(分配失败)

注意：1、在调用malloc之后，一定要判断一下，是否申请内存成功。

​            2、如果多次malloc申请内存，第1次和第2次申请的内存不一定连续。 

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int *p;
    int i,n;
    printf("请输入你要申请的int类型数组的元素给个数")；
    scanf_s("%d",&n);
    p=(int*)malloc(n*4);
    if(p==NULL)
    {
        printf("malloc err\n");
        return 0;
    }
    for(i=0;i<n;i++)
    {
        p[i]=i;
        printf("p[%d]=%d\n",i,p[i]);
    }
    free(p);//归还内存
   return 0;
}
```

### **2、free函数**

**头文件**：#include<stdlib.h>

**函数定义**：void free（void*ptr）

**函数说明**：free函数释放ptr指向的内存。

**注意**：ptr指向的内存必须是malloc calloc relloc动态申请的内存

```c
char *p=(char*)malloc(100);
free(p);
```

**注意**：（1）free后，因为没有给p赋值，所以p还是指向原先动态申请的内存。但是内存已经不能在使用了，p就变成了野指针。

​           （2）一块动态申请的内存只能free一次，不能多次free。

### 3、calloc函数

**头文件**：#include<stdlib.h>

**函数定义**：void*calloc(size_t nmemb,size_t size);

size_t实际是无符号整型，它是头文件中，用**typedef**定义出来的。

**函数功能**：在内存的堆中，申请nmemb块，每块的大小为size个字节的连续区域

**函数的返回值**：

返回申请的内存的首地址（申请成功）

返回NULL（申请失败）

**注意**：malloc和calloc函数都是用来申请内存的。

**区别**：

1）函数名字不一样

2）参数的个数不一样

3）malloc申请的内存存放的内容是随机的，不是确定的，而calloc申请的内存中的内容为0。

```c
//调用方法：在堆中申请了3块，每块大小为100个字节，即300个字节连续的区域。
char*p=(char*)calloc(3,100);
```

### 4、relloc函数

 咱们调用malloc和calloc函数，单次申请的内存是连续的，两次申请的两块内存不一定连续。有时候有这种需求，即我先用malloc或calloc申请一块内存，我还想在原先内存的基础上挨着继续申请内存。或者我开始使用malloc或calloc申请了一块内存，我想释放后边的一部分内存，为了解决这个问题，发明了relloc函数。



**头文件**：#include<stdlib.h>

**函数的定义**：void*relloc（void *s，unsigned int newsize）；

**函数功能**：在原先s指向的内存基础上重新申请内存，新的内存大小为new_size个字节，如果原先内存后面有足够大的空间，就追加，如果后边的内存不够用，则relloc函数会在堆区找一个newsize个字节大小的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新的内存地址。

```c
p=(char*)malloc(100);
p=(char*)relloc(p,150);
```

![68135333439](C:\Users\鲁文豪\AppData\Local\Temp\1681353334395.png)

## 四、内存泄露

**概念**：申请的内存，首地址丢了，再也没法使用，也无法释放，这块内存就被泄露了。

例1：

```c
int main()
{
    char*p;
    p=(char*)malloc(100);
    //接下来可以用p指向申请的内存
    p="hello world";//p指向别的地方了
    //从此之后，再也找不到你申请的100个字节了，即动态申请的100个字节被泄露了。
    return 0;
}
```

例2：

```c
void fun()
{
 char*p;
    p=(char*)malloc(100);
    //接下来可以用p指向申请的内存
}
int main()
{
    fun();
    fun();
    //因为没有得到释放，重复调用，每调用一次就泄露100个字节
    return 0;
}
```

解决方法：

（1）

```c
void fun()
{
 char*p;
    p=(char*)malloc(100);
    //接下来可以用p指向申请的内存
    free(p);//释放内存
}
```

（2）

```c
void fun()
{
 char*p;
    p=(char*)malloc(100);
    //接下来可以用p指向申请的内存
    return p;
}
int main()
{
    char*q;
    q=fun();
    //通过q使用动态申请的100个字节的内存
    free(q);//释放内存
    return 0;
}
```

总结：申请的内存，一定不要把首地址给丢了，在不用的时候一定要释放内存。